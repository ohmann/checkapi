#!/bin/sh

### Default variables
filename="out.dtrace"
buf="10m"

shift `expr $OPTIND - 1`

# Get the command to trace
if [ "$*" = "" ]; then
	echo "Please give the command to trace"
	exit
fi
command="$*"

# Define D Script
dtrace='
#pragma D option quiet
#pragma D option switchrate=10

dtrace:::BEGIN 
{
  err[0] = "";
  err[EPERM] = "EPERM";
  err[ENOENT] = "ENOENT";
  err[ESRCH] = "ESRCH";
  err[EINTR] = "EINTR";
  err[EIO] = "EIO";
  err[ENXIO] = "ENXIO";
  err[E2BIG] = "E2BIG";
  err[ENOEXEC] = "ENOEXEC";
  err[EBADF] = "EBADF";
  err[ECHILD] = "ECHILD";
  err[EAGAIN] = "EAGAIN";
  err[ENOMEM] = "ENOMEM";
  err[EACCES] = "EACCES";
  err[EFAULT] = "EFAULT";
  err[ENOTBLK] = "ENOTBLK";
  err[EBUSY] = "EBUSY";
  err[EEXIST] = "EEXIST";
  err[EXDEV] = "EXDEV";
  err[ENODEV] = "ENODEV";
  err[ENOTDIR] = "ENOTDIR";
  err[EISDIR] = "EISDIR";
  err[EINVAL] = "EINVAL";
  err[ENFILE] = "ENFILE";
  err[EMFILE] = "EMFILE";
  err[ENOTTY] = "ENOTTY";
  err[ETXTBSY] = "ETXTBSY";
  err[EFBIG] = "EFBIG";
  err[ENOSPC] = "ENOSPC";
  err[ESPIPE] = "ESPIPE";
  err[EROFS] = "EROFS";
  err[EMLINK] = "EMLINK";
  err[EPIPE] = "EPIPE";
  err[EDOM] = "EDOM";
  err[ERANGE] = "ERANGE";
  err[ENOMSG] = "ENOMSG";
  err[EIDRM] = "EIDRM";
  /* err[ECHRNG] = "ECHRNG";
  err[EL2NSYNC] = "EL2NSYNC";
  err[EL3HLT] = "EL3HLT";
  err[EL3RST] = "EL3RST";
  err[ELNRNG] = "ELNRNG";
  err[EUNATCH] = "EUNATCH";
  err[ENOCSI] = "ENOCSI";
  err[EL2HLT] = "EL2HLT";
  err[EDEADLK] = "EDEADLK";
  err[ENOLCK] = "ENOLCK";
  err[ECANCELED] = "ECANCELED";
  err[ENOTSUP] = "ENOTSUP";
  err[EDQUOT] = "EDQUOT";
  err[EBADE] = "EBADE";
  err[EBADR] = "EBADR";
  err[EXFULL] = "EXFULL";
  err[ENOANO] = "ENOANO";
  err[EBADRQC] = "EBADRQC";
  err[EBADSLT] = "EBADSLT";
  err[EDEADLOCK] = "EDEADLOCK";
  err[EBFONT] = "EBFONT";
  err[EOWNERDEAD] = "EOWNERDEAD";
  err[ENOTRECOVERABLE] = "ENOTRECOVERABLE";
  err[ENOSTR] = "ENOSTR";
  err[ENODATA] = "ENODATA";
  err[ETIME] = "ETIME";
  err[ENOSR] = "ENOSR";
  err[ENONET] = "ENONET";
  err[ENOPKG] = "ENOPKG";
  err[EREMOTE] = "EREMOTE";
  err[ENOLINK] = "ENOLINK";
  err[EADV] = "EADV";
  err[ESRMNT] = "ESRMNT";
  err[ECOMM] = "ECOMM";
  err[EPROTO] = "EPROTO";
  err[ELOCKUNMAPPED] = "ELOCKUNMAPPED";
  err[ENOTACTIVE] = "ENOTACTIVE";
  err[EMULTIHOP] = "EMULTIHOP";
  err[EBADMSG] = "EBADMSG";
  err[ENAMETOOLONG] = "ENAMETOOLONG";
  err[EOVERFLOW] = "EOVERFLOW";
  err[ENOTUNIQ] = "ENOTUNIQ";
  err[EBADFD] = "EBADFD";
  err[EREMCHG] = "EREMCHG";
  err[ELIBACC] = "ELIBACC";
  err[ELIBBAD] = "ELIBBAD";
  err[ELIBSCN] = "ELIBSCN";
  err[ELIBMAX] = "ELIBMAX";
  err[ELIBEXEC] = "ELIBEXEC";
  err[EILSEQ] = "EILSEQ";
  err[ENOSYS] = "ENOSYS";
  err[ELOOP] = "ELOOP";
  err[ERESTART] = "ERESTART";
  err[ESTRPIPE] = "ESTRPIPE";
  err[ENOTEMPTY] = "ENOTEMPTY";
  err[EUSERS] = "EUSERS";
  err[ENOTSOCK] = "ENOTSOCK";
  err[EDESTADDRREQ] = "EDESTADDRREQ";
  err[EMSGSIZE] = "EMSGSIZE";
  err[EPROTOTYPE] = "EPROTOTYPE";
  err[ENOPROTOOPT] = "ENOPROTOOPT";
  err[EPROTONOSUPPORT] = "EPROTONOSUPPORT";
  err[ESOCKTNOSUPPORT] = "ESOCKTNOSUPPORT";
  err[EOPNOTSUPP] = "EOPNOTSUPP";
  err[EPFNOSUPPORT] = "EPFNOSUPPORT";
  err[EAFNOSUPPORT] = "EAFNOSUPPORT";
  err[EADDRINUSE] = "EADDRINUSE";
  err[EADDRNOTAVAIL] = "EADDRNOTAVAIL";
  err[ENETDOWN] = "ENETDOWN";
  err[ENETUNREACH] = "ENETUNREACH";
  err[ENETRESET] = "ENETRESET";
  err[ECONNABORTED] = "ECONNABORTED";
  err[ECONNRESET] = "ECONNRESET";
  err[ENOBUFS] = "ENOBUFS";
  err[EISCONN] = "EISCONN";
  err[ENOTCONN] = "ENOTCONN";
  err[ESHUTDOWN] = "ESHUTDOWN";
  err[ETOOMANYREFS] = "ETOOMANYREFS";
  err[ETIMEDOUT] = "ETIMEDOUT";
  err[ECONNREFUSED] = "ECONNREFUSED";
  err[EHOSTDOWN] = "EHOSTDOWN";
  err[EHOSTUNREACH] = "EHOSTUNREACH";
  err[EWOULDBLOCK] = "EWOULDBLOCK";
  err[EALREADY] = "EALREADY";
  err[EINPROGRESS] = "EINPROGRESS";
  err[ESTALE] = "ESTALE";*/
}


/* ===GETSOCKNAME/GETPEERNAME===
 * int getsockname(int  s,  struct  sockaddr  *name,  socklen_t *namelen);
 * int getpeername(int  s,  struct  sockaddr  *name,  socklen_t *namelen);
 * int      accept(int  s,  struct  sockaddr  *addr,  socklen_t *addrlen);
 */
syscall::*getsockname*:entry,
syscall::*getpeername*:entry,
syscall::*accept*:entry
{
  self->start = timestamp;
  self->arg0 = arg0;
  self->arg1 = arg1;
  self->arg2 = arg2;
  
}

syscall::*getsockname*:return,
syscall::*getpeername*:return,
syscall::*accept*:return
/self->start/
{
  this->sock = (struct sockaddr_in *) copyin(self->arg1, sizeof(struct sockaddr));
  
  self->family = this->sock->sin_family;

  self->port = ntohs(this->sock->sin_port);
  
  this->a = (uint8_t *)&this->sock->sin_addr;
  this->addr1 = strjoin(lltostr(this->a[0] + 0ULL), strjoin(".",
  strjoin(lltostr(this->a[1] + 0ULL), ".")));
  this->addr2 = strjoin(lltostr(this->a[2] + 0ULL), strjoin(".",
  lltostr(this->a[3] + 0ULL)));
  self->ip = strjoin(this->addr1, this->addr2);
  
  self->len = *(socklen_t *) copyin(self->arg2, sizeof(socklen_t));
            
  printf("%d ", pid);
  printf("%s", probefunc);
  printf("(%d, {sa_family=%d, sin_port=htons(%d), sin_addr=inet_addr(\"%s\")}, %d)\t\t "
         , self->arg0
         , self->family
         , self->port
         , self->ip
         , self->len);
  
  this->errstr = err[errno] != NULL ? err[errno] : "";
  printf("= %d %s\n", (int) arg0, this->errstr);
  
  self->arg0 = 0;
  self->arg1 = 0;
  self->arg2 = 0;
  self->start = 0;
}


/* ===ACCESS===
 * int access(const char *path, int amode);
 * int  mkdir(const char *path, mode_t mode);
 * int creat(const char *path, mode_t mode);
 *
 */
syscall::*access*:entry,
syscall::*mkdir*:entry,
syscall::*creat*:entry
{
  self->start = timestamp;
  self->arg0 = arg0;
  self->arg1 = arg1;
}
syscall::*access*:return,
syscall::*mkdir*:return,
syscall::*creat*:return
/self->start/
{
  printf("%d ", pid);
  printf("%s", probefunc);
  printf("(\"%S\", %d)\t\t "
         , copyinstr(self->arg0)
         , self->arg1);
  
  this->errstr = err[errno] != NULL ? err[errno] : "";
  printf("= %d %s\n", (int) arg0, this->errstr);
  
  self->arg0 = 0;
  self->arg1 = 0;
  self->start = 0;
}


/* ===BIND/CONNECT===
 * int bind(int s, const struct sockaddr *name, int namelen);
 * int connect(int s, const struct sockaddr *name, int namelen);
 *
 */
syscall::*bind*:entry,
syscall::*connect*:entry
{
  self->start = timestamp;
  self->arg0 = arg0;
  self->arg1 = arg1;
  self->arg2 = arg2;
  
}
syscall::*bind*:return,
syscall::*connect*:return
/self->start/
{
  this->sock = (struct sockaddr_in *) copyin(
                 self->arg1, sizeof(struct sockaddr));
  
  self->family = this->sock->sin_family;

  self->port = ntohs(this->sock->sin_port);
  
  this->a = (uint8_t *)&this->sock->sin_addr;
  this->addr1 = strjoin(lltostr(this->a[0] + 0ULL), strjoin(".",
  strjoin(lltostr(this->a[1] + 0ULL), ".")));
  this->addr2 = strjoin(lltostr(this->a[2] + 0ULL), strjoin(".",
  lltostr(this->a[3] + 0ULL)));
  
  self->ip = strjoin(this->addr1, this->addr2);
  
  
  printf("%d ", pid);
  printf("%s", probefunc);
  printf("(%d, {sa_family=%d, sin_port=htons(%d), sin_addr=inet_addr(\"%s\")}, %d)\t\t "
         , self->arg0
         , self->family
         , self->port
         , self->ip
         , self->arg2);
  
  this->errstr = err[errno] != NULL ? err[errno] : "";
  printf("= %d %s\n", (int) arg0, this->errstr);
  
  self->arg0 = 0;
  self->arg1 = 0;
  self->arg2 = 0;
  self->start = 0;
}


/* ===CHDIR/RMDIR/UNLINK===
 * int chdir(const char *path);
 * int rmdir(const char *path);
 * int unlink(const char *path);
 * 
 * 
 */
syscall::chdir*:entry,
syscall::rmdir*:entry,
syscall::unlink*:entry
{
  self->start = timestamp;
  self->arg0 = arg0;
}
syscall::chdir*:return,
syscall::rmdir*:return,
syscall::unlink*:return
/self->start/
{
  printf("%d ", pid);
  printf("%s", probefunc);
  printf("(\"%S\")\t\t "
         , copyinstr(self->arg0));
  
  this->errstr = err[errno] != NULL ? err[errno] : "";
  printf("= %d %s\n", (int) arg0, this->errstr);
  
  self->arg0 = 0;
  self->start = 0;
}


/* ===CLOSE/DUP===
 * int close(int fd);
 */
syscall::*close*:entry,
syscall::*dup:entry
{
  self->start = timestamp;
  self->arg0 = arg0;
}
syscall::*close*:return,
syscall::*dup:return
/self->start/
{
  printf("%d ", pid);
  printf("%s", probefunc);
  printf("(%d)\t\t "
         , self->arg0);
  
  this->errstr = err[errno] != NULL ? err[errno] : "";
  printf("= %d %s\n", (int) arg0, this->errstr);
  
  self->arg0 = 0;
  self->start = 0;
}


/* ===DUP2===
 * int dup2(int oldfd, int newfd);
 */
syscall::dup2*:entry
{
  self->start = timestamp;
  self->arg0 = arg0;
  self->arg1 = arg1;
}
syscall::dup2*:return
/self->start/
{
  printf("%d ", pid);
  printf("%s", probefunc);
  printf("(%d, %d)\t\t "
         , self->arg0
         , self->arg1);
  
  this->errstr = err[errno] != NULL ? err[errno] : "";
  printf("= %d %s\n", (int) arg0, this->errstr);
  
  self->arg0 = 0;
  self->start = 0;
}


/* ===FCNTL===
 * int fcntl(int fildes, int cmd, / arg / ...);
 *
 */
syscall::fcntl*:entry
{
  self->start = timestamp;
  self->arg0 = arg0;
  self->arg1 = arg1;
  self->arg2 = arg2;
}
syscall::fcntl*:return
/self->start/
{
  printf("%d ", pid);
  printf("%s(%d, %d, %d)\t\t " , probefunc
                       , self->arg0
                       , self->arg1
                       , self->arg2);
  
  this->errstr = err[errno] != NULL ? err[errno] : "";
  printf("= %d %s\n", (int) arg0, this->errstr);
  
  self->arg0 = 0;
  self->start = 0;
}


/* ===STAT===
 * int stat(const char *path, struct stat *buf);
 *
 */
syscall::stat:entry
{
  self->start = timestamp;
  self->arg0 = arg0;
  self->arg1 = arg1;
}

syscall::stat:return
/self->start/
{
  this->path = copyinstr(self->arg0);
  
  this->stat = (struct stat*) copyin((uintptr_t) self->arg1, sizeof(struct stat));

  /*
  11433 stat64("syscalls.txt", {st_dev=makedev(8, 6), 
                                st_ino=700117, 
                                st_mode=S_IFREG|0664, 
                                st_nlink=1, 
                                st_uid=1000, 
                                st_gid=1000, 
                                st_blksize=4096, 
                                st_blocks=0, 
                                st_size=0, 
                                st_atime=2013/03/06-04:16:17, 
                                st_mtime=2013/03/06-04:16:17, 
                                st_ctime=2013/03/06-04:16:17}) = 0
  */
  
  printf("%d ", pid);
  printf("%s(%S, {st_dev=%d, st_ino=%d, st_mode=%d, st_nlink=%d, st_uid=%d, st_gid=%d, st_blksize=%d, st_blocks=%d, st_size=%d, st_atime=%d, st_mtime=%d, st_ctime=%d})\t\t ", 
                  probefunc,
                  this->path,
                  this->stat->st_dev,
                  this->stat->st_ino,
                  this->stat->st_mode,
                  this->stat->st_nlink,
                  this->stat->st_uid,
                  this->stat->st_gid,
                  this->stat->st_blksize,
                  this->stat->st_blocks,
                  this->stat->st_size,
                  this->stat->st_atim.tv_sec*1000*1000*1000 + this->stat->st_atim.tv_nsec,
                  this->stat->st_mtim.tv_sec*1000*1000*1000 + this->stat->st_mtim.tv_nsec,
                  this->stat->st_ctim.tv_sec*1000*1000*1000 + this->stat->st_ctim.tv_nsec);

  this->errstr = err[errno] != NULL ? err[errno] : "";
  printf("= %d %s\n", (int) arg0, this->errstr);
  
  self->arg0 = 0;
  self->arg1 = 0;
  self->start = 0;
}















/* ===SOCKET===
 * int socket(int domain, int type, int protocol);
 */
syscall::*socket*:entry
{
  self->start = timestamp;
  self->arg0 = arg0;
  self->arg1 = arg1;
  self->arg2 = arg2;
}
syscall::*socket*:return
/self->start/
{
  printf("%d ", pid);
  printf("%s", "socket");
  printf("(%d, %d, %d)\t\t "
         , self->arg0
         , self->arg1
         , self->arg2);
  
  this->errstr = err[errno] != NULL ? err[errno] : "";
  printf("= %d %s\n", (int) arg0, this->errstr);
  
	self->arg0 = 0;
	self->arg1 = 0;
	self->arg2 = 0;
	self->start = 0;
}


/* program exited */
proc:::exit
/pid == $target/
{
	exit(0);
}


dtrace:::END
{
}
'

### Run DTrace
rm -f $filename
/usr/sbin/dtrace -x dynvarsize=$buf -x evaltime=exec -n "$dtrace" \
      -c "$command" -o $filename