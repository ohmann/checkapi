"""
<Program Name>
  verify-posix.repy

<Started>
  February 12, 2013

<Author>
  egkesi01@students.poly.edu
  Eleni Gessiou

<Purpose>
  Verifies system call traces against the posix filesystem API.

<Usage>
  NOTE: Must be executed with librepy.repy:
  python repy.py restrictions.full encasementlib.repy dylink.repy librepy.repy verify-posix.repy

<Note>
  For posix verifification, setting the initial repy model's filesystem in this file:
  check_api_initial_filestate.input
  is not necessary.

"""

dy_import_module_symbols("check_api.repy")
dy_import_module_symbols("wrapped_lind_net_calls.py")
dy_import_module_symbols("wrapped_lind_fs_calls.py")
#dy_import_module_symbols("posix_test_harness_functions.py")
dy_import_module_symbols("posix_strace_parser.py")


net_syscall_map = {'getsockname_syscall':getsockname_syscall,
               'getpeername_syscall':getpeername_syscall,
               'listen_syscall':listen_syscall,          
               'accept_syscall':accept_syscall,          
               'getsockopt_syscall':getsockopt_syscall,  
               'setsockopt_syscall':setsockopt_syscall,  
               'setshutdown_syscall':setshutdown_syscall,
               'socket_syscall':socket_syscall,          
               'bind_syscall':bind_syscall,              
               'connect_syscall':connect_syscall,        
               'sendto_syscall':sendto_syscall,          
               'send_syscall':send_syscall,              
               'recvfrom_syscall':recvfrom_syscall,      
               'recv_syscall':recv_syscall}

fs_syscall_map = {'access_syscall':access_syscall,
               'chdir_syscall':chdir_syscall,
               'close_syscall':close_syscall,
               'creat_syscall':creat_syscall,
               'dup2_syscall':dup2_syscall,
               'dup_syscall':dup_syscall,
               'fcntl_syscall':fcntl_syscall,
               'fstat_syscall':fstat_syscall,
               'fstatfs_syscall':fstatfs_syscall,
               'getdents_syscall':getdents_syscall,
               'link_syscall':link_syscall,
               'lseek_syscall':lseek_syscall,
               'mkdir_syscall':mkdir_syscall,
               'open_syscall':open_syscall,
               'read_syscall':read_syscall,
               'rmdir_syscall':rmdir_syscall,
               'stat_syscall':stat_syscall,
               'statfs_syscall':statfs_syscall,
               'unlink_syscall':unlink_syscall,
               'write_syscall':write_syscall}

oracle_required_funcs = ['connect_syscall', 'sendto_syscall', 
                         'getsockname_syscall', 'accept_syscall']

fd_call_map = {"fstatfs_syscall":fstatfs_syscall,
               "fstat_syscall":fstat_syscall,
               "lseek_syscall":lseek_syscall,
               "read_syscall":read_syscall,
               "write_syscall":write_syscall,
               "close_syscall":close_syscall,
               "dup2_syscall":dup2_syscall,
               "dup_syscall":dup_syscall,
               "fcntl_syscall":fcntl_syscall,
               "getdents_syscall":getdents_syscall,
               "bind_syscall":bind_syscall,
               "connect_syscall":connect_syscall,
               "sendto_syscall":sendto_syscall,
               "send_syscall":send_syscall,
               "recvfrom_syscall":recvfrom_syscall,
               "recv_syscall":recv_syscall,
               "getsockname_syscall":getsockname_syscall,
               "getpeername_syscall":getpeername_syscall,
               "listen_syscall":listen_syscall,
               "accept_syscall":accept_syscall,
               "getsockopt_syscall":getsockopt_syscall,
               "setsockopt_syscall":setsockopt_syscall,
               "setshutdown_syscall":setshutdown_syscall}

# Jeff-TODO: Probably need to deal with reads on files that we haven't written to? It seems 
#       like we can't verify anything in terms of reads...

posix_fd_map = {}
mycontext['posix_oracle'] = []

DEBUG_VERIF = True


# Create string that has a max length, this helps when printing large strings.
def sstr(data):
  data_short = str(data)[:800]

  if len(str(data)) > len(str(data_short)):
    data_short += "!!SHORTENED STRING!!"
  
  return data_short


# returns the corresponding fd that model uses,
# if it's different from what the implementations uses
def _translate_fd(impl_fd):
  try:
    return posix_fd_map[impl_fd]
  except KeyError:
    #return None
    return impl_fd


# Takes a given list of actions in a trace and attempts to execute you them in 
# the posix model. We are also responsible for keeping track of file-descriptor 
# mappings since the implementation may use different ones from us.
def verify_trace(trace, lNum):

  ERRORS = []
  lineNum = READ_AMNT * lNum

  for action in trace:
    lineNum += 1

    # for debugging reasons, all the actions that are being attempted, can be printed
    if DEBUG_VERIF == True:
      print sstr(lineNum) + " ===> " + sstr(action)
 

    # unpack the action and the return value
    name, args, ret = action
    impl_ret, impl_errno = ret

	
    # what if impl_ret for some reason is something that we don't wait? like -45?
    if impl_ret < -1:
      print "[WARNING] Strange value of return value in the implementation: ", impl_ret
      impl_ret = -1


    # Get the proper function from the function string.
    if name in net_syscall_map:
      fnc = net_syscall_map[name]
    elif name in fs_syscall_map:
      fnc = fs_syscall_map[name]
    else:
      print "[WARNING] I don't know this system call: ", name
      continue


    # Deal with various fd impl->model replacements.
    if name in fd_call_map:
      if name != "dup2_syscall":
        impl_fd = args[0]
	model_fd = _translate_fd(impl_fd)
        
	args = (model_fd,) + args[1:]
      else:
        model_fd1 = _translate_fd(args[0])
	model_fd2 = _translate_fd(args[1])

	args = (model_fd1, model_fd2)


    action = (name, args, ret)
    model_errno = None


    try:
      mycontext['posix_oracle'].append((impl_ret, impl_errno))

      # Execute with the model!!
      model_ret = fnc(*args)

    # If implementation does not implement something so far, make a note of it
    except UnimplementedError, err:
      print 'UnimplmentedError Not Supported!', err, ' : ', action
      continue

    except SyscallError, err:
      model_ret = -1
      model_errno = err[1]
      pass

    # JR: This is a conformance failure, since a POSIX call should 
    # never raise a Repy exception. The Repy model should be
    # transparent to the POSIX model caller.
    except RepyException, err:
      log('ConformanceFaulure! RepyException with action: ', action, '\n')
      raise err

    # if model returns that a fd has been ignored, just print relevant information
    except IgnoredFileDescriptorWarning, err:
      print "IGNORING: ", err[1]
      continue


    # EG: there is no way to verify the results, only its success/failure,
    # because model assigns semi-'random' values. So, just return 'OK'
    if name in ['fstat_syscall', 'fstatfs_syscall'] and model_ret != -1 and impl_ret == 0:
      print "OK"

    # Skip file syscalls on files that don't already exist in posix model
    if name in ['statfs_syscall', 'access_syscall', 'link_syscall', 'unlink_syscall', 'stat_syscall', 
		'chdir_syscall', 'mkdir_syscall', 'rmdir_syscall']:
      if model_errno != impl_errno or model_ret != impl_ret:
        print "IGNORING: " + str(action) + ". Model returned ", model_errno, model_ret, " which do not match with the implementation."
        continue
    
    # If file doesn't exist in POSIX but exists on system (like .so library files), 
    # then add open fd to ignore_fd to ignore future calls to that fd
    if name in ['open_syscall', 'creat_syscall']:

      if impl_errno == None and model_errno != impl_errno:
        print "IGNORING: " + str(action) + ", because model returned an error: ", model_errno

        # EG: I have no other option but to use the ignore_fd here, 
        # because the verifier only should check the return value
        ignore_fd.append(impl_ret)

        #EG: remove any mapping between model and impl fd, even if the syscalls fail
        try:
          del posix_fd_map[impl_ret]
        except:
          pass

        continue
    

    # if model returns different fd than the implementation, keep the correspodance
    # EG: I added dup_syscall
    if name in ['socket_syscall', 'open_syscall', 'creat_syscall', 'dup_syscall', 'dup2_syscall'] and impl_ret != -1:
      posix_fd_map[impl_ret] = model_ret
      model_ret = impl_ret


    # accept returns a tuple of (ip, port, fd), but we need only the fd
    if name  == 'accept_syscall' and impl_ret != -1:
      # check if ip addrs and ports match
      if model_ret[0] == impl_errno[2] and model_ret[1] == impl_errno[1]:
        posix_fd_map[impl_ret] = model_ret[2]
        model_ret = impl_ret
        

    # FS model doesn't need the oracle and a handful of network calls also 
    # don't need it.
    if name in fs_syscall_map or name not in oracle_required_funcs:
      mycontext['posix_oracle'].pop()



    # VERIFY RESULTS! 
    # Currently we are just printing them out to visually 
    # verify we are getting something sane.
   
    # many syscalls need special care in order to check if the results from
    # the parser match the results from the model. That is because parser's
    # results are general-purpose and more verbose than we need in this project.


    if name == "accept_syscall" and impl_ret == model_ret and impl_ret != -1:
      print sstr(lineNum) + " OK: " + name + sstr(args) + ' -> ' + sstr((impl_ret, impl_errno)) + "  " + sstr((model_ret, model_errno))
    # check if port, ip addr match
    elif (name == 'getpeername_syscall' or name == 'getsockname_syscall') and impl_errno[1:3] == model_ret:
      print sstr(lineNum) + " OK: " + name + sstr(args) + ' -> ' + sstr((impl_ret, impl_errno)) + "  " + sstr((model_ret, model_errno))

    # check the value for the option
    elif name == 'getsockopt_syscall' and impl_errno[0] == model_ret:
      print sstr(lineNum) + " OK: " + name + sstr(args) + ' -> ' + sstr((impl_ret, impl_errno)) + "  " + sstr((model_ret, model_errno))

    elif name == 'read_syscall' and impl_ret == model_ret:
      print sstr(lineNum) + " OK: " + name + sstr(args) + ' -> ' + sstr((impl_ret, impl_errno)) + "  " + sstr((model_ret, model_errno))

    elif impl_ret != model_ret or impl_errno != model_errno:
      print sstr(lineNum * num) + " ERROR: " + name + sstr(args) + ' -> ' + sstr((impl_ret, impl_errno)) + "  " + sstr((model_ret, model_errno))
      ERRORS.append(sstr(lineNum * num) + " ERROR: " + name + sstr(args) + ' -> ' + sstr((impl_ret, impl_errno)) + "  " + sstr((model_ret, model_errno)))

    else:
      print sstr(lineNum) + " OK: " + name + sstr(args) + ' -> ' + sstr((impl_ret, impl_errno)) + "  " + sstr((model_ret, model_errno))

  return ERRORS



ERROR_FILE = "errors.txt"
TRACE_FILE_NAME = "write.strace"

READ_AMNT = -1

# Load the initial file state
load_fs()

fh = open(TRACE_FILE_NAME, "r")
#trace = getNumberValidTraceLines(fh, READ_AMNT)
trace = get_traces(fh)
num = 0
ERRORS = verify_trace(trace, num)
fh.close()

print "\n\n\n\n\n"


fh = open(ERROR_FILE, "w")
numLines = 0

for line in ERRORS:
  print sstr(line)
  fh.write(line + "\n")
  numLines += 1

fh.write(str(numLines) + " error(s)...\n")
fh.close()

print sstr(numLines) + " error(s)..."


