dy_import_module_symbols("check_api.repy")
dy_import_module_symbols("wrapped_lind_net_calls.py")
dy_import_module_symbols("wrapped_lind_fs_calls.py")
dy_import_module_symbols("posix_test_harness_functions.py")

# Preload file system state.
#preloaded_files = ['/etc/ld.so.cache', ]
#mycontext['model_state']['file_system_contents']

net_syscall_map = {'getsockname_syscall':getsockname_syscall,
               'getpeername_syscall':getpeername_syscall,
               'listen_syscall':listen_syscall,          
               'accept_syscall':accept_syscall,          
               'getsockopt_syscall':getsockopt_syscall,  
               'setsockopt_syscall':setsockopt_syscall,  
               'setshutdown_syscall':setshutdown_syscall,
               'socket_syscall':socket_syscall,          
               'bind_syscall':bind_syscall,              
               'connect_syscall':connect_syscall,        
               'sendto_syscall':sendto_syscall,          
               'send_syscall':send_syscall,              
               'recvfrom_syscall':recvfrom_syscall,      
               'recv_syscall':recv_syscall}

fs_syscall_map = {'access_syscall':access_syscall,
               'chdir_syscall':chdir_syscall,
               'close_syscall':close_syscall,
               'creat_syscall':creat_syscall,
               'dup2_syscall':dup2_syscall,
               'dup_syscall':dup_syscall,
               'fcntl_syscall':fcntl_syscall,
               'fstat_syscall':fstat_syscall,
               'fstatfs_syscall':fstatfs_syscall,
               'getdents_syscall':getdents_syscall,
               'link_syscall':link_syscall,
               'lseek_syscall':lseek_syscall,
               'mkdir_syscall':mkdir_syscall,
               'open_syscall':open_syscall,
               'read_syscall':read_syscall,
               'rmdir_syscall':rmdir_syscall,
               'stat_syscall':stat_syscall,
               'statfs_syscall':statfs_syscall,
               'unlink_syscall':unlink_syscall,
               'write_syscall':write_syscall}

oracle_required_funcs = ['connect_syscall', 'sendto_syscall', 
                         'getsockname_syscall']

fd_call_map = {"fstatfs_syscall":fstatfs_syscall,
               "fstat_syscall":fstat_syscall,
               "lseek_syscall":lseek_syscall,
               "read_syscall":read_syscall,
               "write_syscall":write_syscall,
               "close_syscall":close_syscall,
               "dup2_syscall":dup2_syscall,
               "dup_syscall":dup_syscall,
               "fcntl_syscall":fcntl_syscall,
               "getdents_syscall":getdents_syscall,
               "bind_syscall":bind_syscall,
               "connect_syscall":connect_syscall,
               "sendto_syscall":sendto_syscall,
               "send_syscall":send_syscall,
               "recvfrom_syscall":recvfrom_syscall,
               "recv_syscall":recv_syscall,
               "getsockname_syscall":getsockname_syscall,
               "getpeername_syscall":getpeername_syscall,
               "listen_syscall":listen_syscall,
               "accept_syscall":accept_syscall,
               "getsockopt_syscall":getsockopt_syscall,
               "setsockopt_syscall":setsockopt_syscall,
               "setshutdown_syscall":setshutdown_syscall}

# TODO: Probably need to deal with reads on files that we haven't written to? It seems 
#       like we can't verify anything in terms of reads...

posix_fd_map = {}
ignore_fd = [0,1,2]
mycontext['posix_oracle'] = []




def _translate_fd(impl_fd):
    try:
        return posix_fd_map[impl_fd]
    except KeyError:
        return None


def _duplicate_filesystem():
    #for directory, directories, files in os.walk("/"):
     #   print directory
    pass



# Takes a given list of actions in a trace and attempts to execute you them in 
# the posix model. We are also responsible for keeping track of file-descriptor 
# mappings since the implementation may use different ones from us.
def verify_trace(trace, num):
    lineNum = 0
    for action in trace:
        lineNum += 1
        #print str(lineNum) + " ===> " + str(action)
        #log(str(lineNum) + "\n")
        name, args, ret = action
        impl_ret, impl_errno = ret

        # Get the proper function from the function string.
        if name in net_syscall_map:
            fnc = net_syscall_map[name]
            #log(name, '\n')
        elif name in fs_syscall_map:
            fnc = fs_syscall_map[name]
            #log(name, '\n')

        # Ignore syscalls to nonexistant file descriptors
        if name in ['fstatfs_syscall', 'fstat_syscall', 'lseek_syscall', 'read_syscall', 'write_syscall', 'dup2_syscall', 'dup_syscall', 'fcntl_syscall', 'getdents_syscall', 'bind_syscall', 'connect_syscall', 'sendto_syscall', 'send_syscall', 'recvfrom_syscall', 'recv_syscall', 'getsockname_syscall', 'getpeername_syscall', 'listen_syscall', 'accept_syscall', 'getsockopt_syscall', 'setsockopt_syscall', 'setshutdown_syscall']:
            if args[0] in ignore_fd:
                #print "IGNORING: " + str(action)
                continue

        # Is an ignored file descriptor being closed?
        if name == 'close_syscall':
            if args[0] in ignore_fd:
                #print "REMOVING: " + str(action)
                ignore_fd.pop(ignore_fd.index(args[0]))
                continue
            else:
                #print str(args[0]) + " ==> " + str(ignore_fd)
                pass

        # Deal with various fd impl->model replacements.
        if name in fd_call_map:
            if name != "dup2_syscall":
                impl_fd = args[0]
                model_fd = _translate_fd(impl_fd)
                if model_fd is None:
                    print "Unknown fd:", action
                    return
                    #log('Unknown fd:', action, '\n')
                    continue
                args = (model_fd,) + args[1:]
            else:
                model_fd1 = _translate_fd(args[0])
                model_fd2 = _translate_fd(args[1])
                if model_fd1 is None or model_fd2 is None:
                    print "Unknown fd:", action
                    #log('Unknown fd(s):', action, '\n')
                    continue
                args = (model_fd1, model_fd2)

        action = (name, args, ret)
        model_errno = None
        try:
            mycontext['posix_oracle'].append((impl_ret, impl_errno))
            model_ret = fnc(*args)
        except UnimplementedError:
            log('UnimplmentedError Not Supported:', action, '\n')
            if name in ['open_syscall', 'creat_syscall', 'socket_syscall']:
                ignore_fd.append(impl_ret)
                #print str(posix_fd_map)
                #try:
                    #print posix_fd_map[args[0]]
                #except:
                    #print "NO GOOD..."
            continue
        except SyscallError, err:
            model_ret = -1
            model_errno = err[1]
            pass

        # Skip file syscalls on files that don't already exist in posix model
        if name in ['statfs_syscall', 'access_syscall', 'link_syscall', 'unlink_syscall', 'stat_syscall', 
                    'chdir_syscall', 'mkdir_syscall', 'rmdir_syscall']:
            if model_errno != impl_errno or model_ret != impl_ret:
                #print "IGNORING: " + str(action)
                continue

        # If file doesn't exist in POSIX but exists on system, then add open fd to ignore_fd to ignore future calls to that fd
        if name in ['open_syscall', 'creat_syscall']:
            if impl_errno == None and model_errno != impl_errno:
                #print "IGNORING: " + str(action)
                ignore_fd.append(impl_ret)
                continue
            else:
                #print "NOT IGNORING: " + str(action)
                pass

        if name in ['socket_syscall', 'open_syscall', 'creat_syscall'] and impl_ret != -1:
            posix_fd_map[impl_ret] = model_ret
            model_ret = impl_ret

        # FS model doesn't need the oracle and a handful of network calls also 
        # don't need it.
        if name in fs_syscall_map or name not in oracle_required_funcs:
            mycontext['posix_oracle'].pop()

        # VERIFY RESULTS! Currently we are just printing them out to visually 
        # verify we are getting something sane.
        if impl_ret != model_ret or impl_errno != model_errno:
            print str(lineNum * num) + " ERROR: " + name + str(args) + ' -> ' + str((impl_ret, impl_errno)) + "  " + str((model_ret, model_errno))
            return False
        else:
            print str(lineNum * num) + " OK: " + name + str(args) + ' -> ' + str((impl_ret, impl_errno)) + "  " + str((model_ret, model_errno))
        #log(name + str(args), '-> ', (impl_ret, impl_errno), (model_ret, model_errno), '\n')
    return True

#TRACE_FILE_NAME = "putty_ubuntu.strace_full"
#TRACE_FILE_NAME = "firefox.strace_full"
TRACE_FILE_NAME = "skype.strace_network"
#TRACE_FILE_NAME = "simple.trace"
READ_AMNT = 512

fh = open(TRACE_FILE_NAME, "r")
_duplicate_filesystem()

#log(len(trace), '\n')
#for a in trace:
#    log(a,'\n')
#trace = [('socket_syscall', (2, 1, 0), (14, None)), ('close_syscall', (14,), (0, None))]
#trace = [('open_syscall', ("test", 0100, 0666), (3, None)), ('close_syscall', (3,), (0, None))]
#open("/home/monzum/.kde/share/apps/ktorrent/magnets", O_WRONLY|O_CREAT|O_TRUNC|O_LARGEFILE, 0666) = 3

trace = getNumberValidTraceLines(fh, READ_AMNT)
num = 1
verify_trace(trace, num)
while len(trace) > 0:
    if not verify_trace(trace, num):
        break
    num += 1
    trace = getNumberValidTraceLines(fh, READ_AMNT)
