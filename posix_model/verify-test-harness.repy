'''
NOTE: Must be executed with librepy.repy:
python repy.py restrictions.full encasementlib.repy dylink.repy librepy.repy verify-test-harness.repy 
'''

dy_import_module_symbols("check_api.repy")
dy_import_module_symbols("wrapped_lind_net_calls.py")
dy_import_module_symbols("wrapped_lind_fs_calls.py")
dy_import_module_symbols("posix_test_harness_functions.py")

# Preload file system state.
#preloaded_files = ['/etc/ld.so.cache', ]
#mycontext['model_state']['file_system_contents']

net_syscall_map = {'getsockname_syscall':getsockname_syscall,
               'getpeername_syscall':getpeername_syscall,
               'listen_syscall':listen_syscall,          
               'accept_syscall':accept_syscall,          
               'getsockopt_syscall':getsockopt_syscall,  
               'setsockopt_syscall':setsockopt_syscall,  
               'setshutdown_syscall':setshutdown_syscall,
               'socket_syscall':socket_syscall,          
               'bind_syscall':bind_syscall,              
               'connect_syscall':connect_syscall,        
               'sendto_syscall':sendto_syscall,          
               'send_syscall':send_syscall,              
               'recvfrom_syscall':recvfrom_syscall,      
               'recv_syscall':recv_syscall}

fs_syscall_map = {'access_syscall':access_syscall,
               'chdir_syscall':chdir_syscall,
               'close_syscall':close_syscall,
               'creat_syscall':creat_syscall,
               'dup2_syscall':dup2_syscall,
               'dup_syscall':dup_syscall,
               'fcntl_syscall':fcntl_syscall,
               'fstat_syscall':fstat_syscall,
               'fstatfs_syscall':fstatfs_syscall,
               'getdents_syscall':getdents_syscall,
               'link_syscall':link_syscall,
               'lseek_syscall':lseek_syscall,
               'mkdir_syscall':mkdir_syscall,
               'open_syscall':open_syscall,
               'read_syscall':read_syscall,
               'rmdir_syscall':rmdir_syscall,
               'stat_syscall':stat_syscall,
               'statfs_syscall':statfs_syscall,
               'unlink_syscall':unlink_syscall,
               'write_syscall':write_syscall}

oracle_required_funcs = ['connect_syscall', 'sendto_syscall', 
                         'getsockname_syscall', 'accept_syscall']

fd_call_map = {"fstatfs_syscall":fstatfs_syscall,
               "fstat_syscall":fstat_syscall,
               "lseek_syscall":lseek_syscall,
               "read_syscall":read_syscall,
               "write_syscall":write_syscall,
               "close_syscall":close_syscall,
               "dup2_syscall":dup2_syscall,
               "dup_syscall":dup_syscall,
               "fcntl_syscall":fcntl_syscall,
               "getdents_syscall":getdents_syscall,
               "bind_syscall":bind_syscall,
               "connect_syscall":connect_syscall,
               "sendto_syscall":sendto_syscall,
               "send_syscall":send_syscall,
               "recvfrom_syscall":recvfrom_syscall,
               "recv_syscall":recv_syscall,
               "getsockname_syscall":getsockname_syscall,
               "getpeername_syscall":getpeername_syscall,
               "listen_syscall":listen_syscall,
               "accept_syscall":accept_syscall,
               "getsockopt_syscall":getsockopt_syscall,
               "setsockopt_syscall":setsockopt_syscall,
               "setshutdown_syscall":setshutdown_syscall}

# TODO: Probably need to deal with reads on files that we haven't written to? It seems 
#       like we can't verify anything in terms of reads...

posix_fd_map = {}
ignore_fd = [0,1,2] #standard in/out/error
mycontext['posix_oracle'] = []


# Create string that has a max length, this helps when printing large strings.
def sstr(data):
    data_short = str(data)[:800]
    if len(str(data)) > len(str(data_short)):
        data_short += "!!SHORTENED STRING!!"
    return data_short


def _translate_fd(impl_fd):
    try:
        return posix_fd_map[impl_fd]
    except KeyError:
        return None



# Takes a given list of actions in a trace and attempts to execute you them in 
# the posix model. We are also responsible for keeping track of file-descriptor 
# mappings since the implementation may use different ones from us.
def verify_trace(trace, lNum):
    ERRORS = []
    lineNum = READ_AMNT * lNum
    for action in trace:
        #try:
		lineNum += 1
		print sstr(lineNum) + " ===> " + sstr(action)
		#print str(ignore_fd)
		#print str(posix_fd_map)
		#log(str(lineNum) + "\n")
		name, args, ret = action
		impl_ret, impl_errno = ret

                # EFM: Skipping problem calls like getsockname and fcntl for now...
                if name == 'getsockname_syscall' or name == 'fcntl_syscall':
                    continue

		# Get the proper function from the function string.
		if name in net_syscall_map:
		    fnc = net_syscall_map[name]
		    #log(name, '\n')
		elif name in fs_syscall_map:
		    fnc = fs_syscall_map[name]
		    #log(name, '\n')

		# Ignore syscalls to nonexistant file descriptors
		if name in ['fstatfs_syscall', 'fstat_syscall', 'lseek_syscall', 'read_syscall', 'write_syscall', 'getdents_syscall', 'bind_syscall', 'connect_syscall', 'sendto_syscall', 'send_syscall', 'recvfrom_syscall', 'recv_syscall', 'getsockname_syscall', 'getpeername_syscall', 'listen_syscall', 'accept_syscall', 'getsockopt_syscall', 'setsockopt_syscall', 'setshutdown_syscall']:
		    if args[0] in ignore_fd:
		        #print "IGNORING: " + str(action)
		        continue

		if name in ['dup2_syscall', 'dup_syscall']:
		    if args[0] in ignore_fd:
		        if impl_ret != -1:
		            ignore_fd.append(impl_ret)
		        #print "IGNORING: " + str(action)
		        continue


		if name == 'fcntl_syscall':
		    if args[0] in ignore_fd:
		        if args[1] == ['F_DUPFD'] and impl_ret != -1:
		            ignore_fd.append(impl_ret)
		        #print "IGNORING: " + str(action)
		        continue

		# Is an ignored file descriptor being closed?
		if name == 'close_syscall':
		    if args[0] in ignore_fd:
		        #print "REMOVING: " + str(action)
		        ignore_fd.pop(ignore_fd.index(args[0]))
		        #print str(ignore_fd)
		        continue
		    else:
		        #print str(args[0]) + " ==> " + str(ignore_fd)
		        pass

		# Deal with various fd impl->model replacements.
		if name in fd_call_map:
		    if name != "dup2_syscall":
		        impl_fd = args[0]
		        model_fd = _translate_fd(impl_fd)
		        if model_fd is None:
		            print "Unknown fd:", sstr(action)
		            #return
		            #log('Unknown fd:', action, '\n')
		            continue
		        args = (model_fd,) + args[1:]
		    else:
		        model_fd1 = _translate_fd(args[0])
		        model_fd2 = _translate_fd(args[1])
		        if model_fd1 is None or model_fd2 is None:
		            print "Unknown fd:", sstr(action)
		            #return
		            #log('Unknown fd(s):', action, '\n')
		            continue
		        args = (model_fd1, model_fd2)

                # Special socket side effect patch.
                if name == "accept_syscall":
                    fd, acceptip, acceptport = args
                    args = (fd,)
                    newfd = impl_ret
                    impl_ret = (acceptip, acceptport, newfd)

		action = (name, args, ret)
		model_errno = None
		try:
                    mycontext['posix_oracle'].append((impl_ret, impl_errno))
		    model_ret = fnc(*args)
		except UnimplementedError:
		    log('UnimplmentedError Not Supported:', action, '\n')
		    if name in ['open_syscall', 'creat_syscall', 'socket_syscall']:
		        ignore_fd.append(impl_ret)

		    if name == 'fcntl_syscall':
		        if args[1] == '[F_DUPFD'] and impl_ret != -1:
		            ignore_fd.append(impl_ret)

		    continue

		except SyscallError, err:
		    model_ret = -1
		    model_errno = err[1]
		    pass

                # JR: This is a conformance failure, since a POSIX call should 
                # never raise a Repy exception. The Repy model should be
                # transparent to the POSIX model caller.
                except RepyException, err:
                    log('ConformanceFaulure! RepyException with action: ', action, '\n')
                    raise err

		# Skip file syscalls on files that don't already exist in posix model
		if name in ['statfs_syscall', 'access_syscall', 'link_syscall', 'unlink_syscall', 'stat_syscall', 
		            'chdir_syscall', 'mkdir_syscall', 'rmdir_syscall']:
		    if model_errno != impl_errno or model_ret != impl_ret:
		        #print "IGNORING: " + str(action)
		        continue

		# If file doesn't exist in POSIX but exists on system, then add open fd to ignore_fd to ignore future calls to that fd
		if name in ['open_syscall', 'creat_syscall']:
		    if impl_errno == None and model_errno != impl_errno:
		        #print "IGNORING: " + str(action)
		        ignore_fd.append(impl_ret)
		        continue
		    else:
		        #print "NOT IGNORING: " + str(action)
		        pass

		if name in ['socket_syscall', 'open_syscall', 'creat_syscall'] and impl_ret != -1:
		    posix_fd_map[impl_ret] = model_ret
		    model_ret = impl_ret

		# FS model doesn't need the oracle and a handful of network calls also 
		# don't need it.
		if name in fs_syscall_map or name not in oracle_required_funcs:
		    mycontext['posix_oracle'].pop()

		# VERIFY RESULTS! Currently we are just printing them out to visually 
		# verify we are getting something sane.
                if name == "accept_syscall" and impl_errno == model_errno:
                    # We don't care about the fd returned so lets ignore that comparison
		    print sstr(lineNum) + " OK: " + name + sstr(args) + ' -> ' + sstr((impl_ret, impl_errno)) + "  " + sstr((model_ret, model_errno))
		elif impl_ret != model_ret or impl_errno != model_errno:
		    print sstr(lineNum * num) + " ERROR: " + name + sstr(args) + ' -> ' + sstr((impl_ret, impl_errno)) + "  " + sstr((model_ret, model_errno))
		    ERRORS.append(sstr(lineNum * num) + " ERROR: " + name + sstr(args) + ' -> ' + sstr((impl_ret, impl_errno)) + "  " + sstr((model_ret, model_errno)))
		else:
		    print sstr(lineNum) + " OK: " + name + sstr(args) + ' -> ' + sstr((impl_ret, impl_errno)) + "  " + sstr((model_ret, model_errno))
        #except:
        #    ERRORS.append("SOMETHING REALLY BAD HAPPENED: " + name + str(args))
    return ERRORS

#TRACE_FILE_NAME = "putty_ubuntu.strace_full"
#TRACE_FILE_NAME = "buffull.strace_result"
ERROR_FILE = "errors.txt"
#TRACE_FILE_NAME = "setsockoptafterclose.strace_result"
READ_AMNT = -1

fh = open(TRACE_FILE_NAME, "r")

#log(len(trace), '\n')
#for a in trace:
#    log(a,'\n')
#trace = [('socket_syscall', (2, 1, 0), (14, None)), ('close_syscall', (14,), (0, None))]
#trace = [('open_syscall', ("test", 0100, 0666), (3, None)), ('close_syscall', (3,), (0, None))]
#open("/home/monzum/.kde/share/apps/ktorrent/magnets", O_WRONLY|O_CREAT|O_TRUNC|O_LARGEFILE, 0666) = 3

trace = getNumberValidTraceLines(fh, READ_AMNT)
num = 0
ERRORS = verify_trace(trace, num)
fh.close()
print "\n\n\n\n\n"
fh = open(ERROR_FILE, "w")
numLines = 0
for line in ERRORS:
    print sstr(line)
    fh.write(line + "\n")
    numLines += 1
fh.write(str(numLines) + " error(s)...\n")
fh.close()

print sstr(numLines) + " error(s)..."

#while len(trace) > 0:
#    if not verify_trace(trace, num):
#        break
#    num += 1
#    trace = getNumberValidTraceLines(fh, READ_AMNT)
